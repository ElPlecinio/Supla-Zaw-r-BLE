#define STATUS_LED_GPIO 9
#define STATUS_LED2_GPIO 8
#define RELAY_GPIO 7
#define BUTTON_CFG_RELAY_GPIO 10

#include <SuplaDevice.h>
#include <supla/network/esp_wifi.h>
#include <supla/control/virtual_relay.h>
#include <supla/control/button.h>
#include <supla/control/action_trigger.h>
#include <supla/device/status_led.h>
#include <supla/storage/littlefs_config.h>
#include <supla/network/esp_web_server.h>
#include <supla/network/html/device_info.h>
#include <supla/network/html/protocol_parameters.h>
#include <supla/network/html/status_led_parameters.h>
#include <supla/network/html/wifi_parameters.h>
#include <supla/device/supla_ca_cert.h>
#include <supla/events.h>
#include <supla/sensor/virtual_binary.h>
#include <supla/storage/eeprom.h>
#include <NimBLEDevice.h>
#include <NimBLEScan.h>
#include <NimBLEAdvertisedDevice.h>

unsigned long lastBLEDetectionTime = 0;  // Zmienna do przechowywania czasu ostatniego wykrycia

Supla::Eeprom eeprom;
Supla::ESPWifi wifi;
Supla::LittleFsConfig configSupla;

Supla::Device::StatusLed statusLed(STATUS_LED_GPIO, false); // inverted state
Supla::EspWebServer suplaServer;
Supla::Control::VirtualRelay *r1 = nullptr;
Supla::Sensor::VirtualBinary *cz = nullptr; 
Supla::Control::Button *buttonCfgRelay = nullptr;

Supla::Html::DeviceInfo htmlDeviceInfo(&SuplaDevice);
Supla::Html::WifiParameters htmlWifi;
Supla::Html::ProtocolParameters htmlProto;
Supla::Html::StatusLedParameters htmlStatusLed;

// Lista dozwolonych adresów MAC
const char* allowedMacAddresses[] = {
  "C4:82:E1:B6:4B:EB",
  "11:22:33:44:55:66",
  "77:88:99:AA:BB:CC"
};
// Deklaracja zmiennych do obsługi BLE
NimBLEScan* pBLEScan = nullptr;
// Flaga wskazująca, czy znaleziono zgodny adres MAC
bool bleDeviceFound = false;

// Klasa do obsługi BLE
class MyAdvertisedDeviceCallbacks: public NimBLEAdvertisedDeviceCallbacks {
  void onResult(NimBLEAdvertisedDevice* advertisedDevice) {
    // Wyświetl adres MAC wykrytego urządzenia
   // Serial.print("Wykryto urządzenie BLE o adresie MAC: ");
    //Serial.println(advertisedDevice->getAddress().toString().c_str());

    // Przechodzimy przez listę dozwolonych adresów MAC
    for (int i = 0; i < sizeof(allowedMacAddresses) / sizeof(allowedMacAddresses[0]); i++) {
     //Serial.print("Porównuję z: ");
      //Serial.println(allowedMacAddresses[i]);

      // Porównanie adresów MAC, ignorując wielkość liter
      if (strcasecmp(advertisedDevice->getAddress().toString().c_str(), allowedMacAddresses[i]) == 0) {
       // Serial.println("Znaleziono urządzenie BLE z dopuszczonym adresem MAC!");
        bleDeviceFound = true;
        break; // Przerwanie pętli po znalezieniu zgodnego adresu
      } else {
      //  Serial.println("Adres MAC niezgodny.");
      }
    }
  }
};



void setup() {
  pinMode(STATUS_LED_GPIO, OUTPUT);  // Ustawienie pinu diody LED jako wyjście
  pinMode(STATUS_LED2_GPIO, OUTPUT); // Ustawienie drugiego pinu diody LED jako wyjście
  pinMode(RELAY_GPIO, OUTPUT);  // Ustawienie pinu przekaźnika jako wyjście
  pinMode(BUTTON_CFG_RELAY_GPIO, INPUT_PULLUP);  // Ustawienie pinu przycisku jako wejście z rezystorem pull-up


  
  Serial.begin(115200);
Serial.println("Start programu");
  r1 = new Supla::Control::VirtualRelay();
  cz = new Supla::Sensor::VirtualBinary();
  buttonCfgRelay = new Supla::Control::Button(BUTTON_CFG_RELAY_GPIO, true, true);

  r1->getChannel()->setDefault(SUPLA_CHANNELFNC_VALVE_OPENCLOSE);
  r1->setDefaultStateRestore();
  cz->getChannel()->setDefault(SUPLA_CHANNELFNC_NOLIQUIDSENSOR);


  buttonCfgRelay->configureAsConfigButton(&SuplaDevice);
  buttonCfgRelay->addAction(Supla::TOGGLE, r1, Supla::ON_CLICK_1);

  // Ustawienie certyfikatów dla Supla
  SuplaDevice.setSuplaCACert(suplaCACert);
  SuplaDevice.setSupla3rdPartyCACert(supla3rdCACert);
  SuplaDevice.setName("Supla Zawór BLE");
  

  // Inicjalizacja BLE
  NimBLEDevice::init("Supla BLE Scanner");
        // Konfiguracja mocy sygnału BLE
    NimBLEDevice::setPower(ESP_PWR_LVL_P9);
  pBLEScan = NimBLEDevice::getScan();
  if (pBLEScan != nullptr) {
    pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
    pBLEScan->setInterval(97); // Ustawienie interwału skanowania
    pBLEScan->setWindow(37);   // Ustawienie okna skanowania
    pBLEScan->setActiveScan(true); // Aktywne skanowanie (szybsze)
     pBLEScan->setMaxResults(0);    
    //pBLEScan->start(5, nullptr);  // Skanuj przez 5 sekund
    Serial.println("aaa");
  }

  SuplaDevice.begin();
}

void loop() {
  SuplaDevice.iterate();
  if (pBLEScan != nullptr && !pBLEScan->isScanning()) {
    pBLEScan->start(5, nullptr, false);  // Rozpocznij ponowne skanowanie, jeśli nie trwa
            Serial.println("Skanowanie");
  }

  // Utrzymuj zawór otwarty, jeśli przekaźnik jest włączony
  if (r1 != nullptr && r1->isOn()) {
    digitalWrite(RELAY_GPIO, HIGH);  // Włącz przekaźnik (zasilanie)
    digitalWrite(STATUS_LED_GPIO, HIGH);  // Włącz przekaźnik (zasilanie)
    digitalWrite(STATUS_LED2_GPIO, LOW);  // Włącz przekaźnik (zasilanie)
  } else {
    digitalWrite(RELAY_GPIO, LOW);   // Wyłącz przekaźnik (brak zasilania)
    digitalWrite(STATUS_LED2_GPIO, HIGH);  // Włącz przekaźnik (zasilanie)
    digitalWrite(STATUS_LED_GPIO, LOW);  // Włącz przekaźnik (zasilanie)
  }

  // Obsługa BLE - jeśli wykryto urządzenie, ustaw czujnik na true
  if (bleDeviceFound && cz != nullptr) {
    Serial.println("Wykryto urządzenie BLE z listy.");
    cz->set();  // Ustaw czujnik na true
    lastBLEDetectionTime = millis();  // Zapisz czas wykrycia
    bleDeviceFound = false;  // Zresetuj flagę, aby uniknąć wielokrotnego ustawiania
    r1->turnOff();
  }

  // Sprawdzenie, czy minęło 60 sekund od ostatniego wykrycia
  if (cz != nullptr && millis() - lastBLEDetectionTime > 60000) {
    cz->clear();  // Ustaw czujnik na false po minucie
  }
}
